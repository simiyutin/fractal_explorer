<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Fractal viewer</title>
    <script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>

    <style>
        html, body {
            width:  100%;
            height: 100%;
            overflow: hidden;
            margin: 0;
        }

        canvas {
            border: none;
        }
    </style>



    <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec4 aVertexColor;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;

        varying vec4 vColor;
        varying vec2 zPos;

        void main(void) {
            gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
            vColor = aVertexColor;
            zPos = vec2(aVertexPosition[0], aVertexPosition[1]);
        }
    </script>

    <script id="shader-fs" type="x-shader/x-fragment">

        #define complexMult(a,b) vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x)
        #define complexMag(z) float(pow(length(z), 2.0))
        #define complexReciprocal(z) vec2(z.x / complexMag(z), -z.y / complexMag(z))
        #define complexDivision(a,b) complexMult(a, complexReciprocal(b))
        #define complexArg(z) float(atan(z.y, z.x))
        #define complexLog(z) vec2(log(length(z)), complexArg(z))
        #define complexExp(z) vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y))
        #define sinh(x) float((exp(x) - exp(-x)) / 2.0)
        #define cosh(x) float((exp(x) + exp(-x)) / 2.0)
        #define complexSin(z) vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y))
        #define complexCos(z) vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y))
        #define complexTan(z) vec2(sin(2.0 * z.x)/(cos(2.0 * z.x) + cosh(2.0 * z.y)), sinh(2.0 * z.y)/(cos(2.0 * z.x) + cosh(2.0 * z.y)))
        #define complexSinh(z) vec2(sinh(z.x) * cos(z.y), cosh(z.x) * sin(z.y))
        #define complexCosh(z) vec2(cosh(z.x) * cos(z.y), sinh(z.x) * sin(z.y))
        #define complexTanh(z) vec2(sinh(2.0 * z.x)/(cosh(2.0 * z.a) + cos(2.0 * z.y)), sin(2.0 * z.y)/(cosh(2.0 * z.x) + cos(2.0 * z.y)))
        #define polar(r,a) vec2(cos(a) * r, sin(a) * r)
        #define complexPower(z,p) vec2(polar(pow(length(z), float(p)), float(p) * complexArg(z)))
        #define RED vec4(1.0, 0.0, 0.0, 1.0)
        #define BLACK vec4(0.0, 0.0, 0.0, 1.0)
        #define BLACK vec4(0.0, 0.0, 0.0, 1.0)
        #define CHERRY vec4(0.82, 0.08, 0.08, 1.0)
        #define WHITE vec4(1.0, 1.0, 1.0, 1.0)
        #define maxIterations 50.0
        #define SCALE_FACTOR 3.0


        precision mediump float;

        varying vec4 vColor;
        varying vec2 zPos;

        uniform float zoom;
        uniform vec2 shift;

        uniform sampler2D texSampler;

        bool in_square() {
            float x = zPos[0];
            float y = zPos[1];
            return x >= -1.0 && x <= 1.0 && y >= -1.0 && y <= 1.0;
        }

        bool bailoutLimit(vec2 z) {
            return dot(z, z) >= 16.0;
        }

        vec2 cpow2(vec2 z) {
            return complexPower(z, 2.0);
        }

        float lerp(float f1, float f2, float coef) {
            return f2 * coef + f1 * (1.0 - coef);
        }

        vec4 lerp(vec4 col1, vec4 col2, float coef) {
            float r = lerp(col1[0], col2[0], coef);
            float g = lerp(col1[1], col2[1], coef);
            float b = lerp(col1[2], col2[2], coef);
            float a = lerp(col1[3], col2[3], coef);
            return vec4(r, g, b, a);
        }

        vec4 colorMapping(float n, vec2 z) {
            float coef = n / maxIterations;
            return texture2D(texSampler, vec2(coef, 0.5));
//            return lerp(WHITE, CHERRY, coef);
        }


        vec4 Mandelbrot(vec2 z) {
            vec4  color = vec4(0.0, 0.0, 0.0, 1.0);
            float n = 0.0;
            vec2 c = z;

            for (int i = 0; i < int(maxIterations); i++) {
                n += 1.0;
                z = cpow2(z) + c;

                if (bailoutLimit(z)) {
                    color = colorMapping(n, z);
                    break;
                }
            }

            return color;
        }

        void main(void) {
            if (in_square()) {
                vec2 scaledPos = vec2(zPos[0] * zoom + shift[0], zPos[1] * zoom + shift[1]);
                scaledPos[0] *= SCALE_FACTOR;
                scaledPos[1] *= SCALE_FACTOR;
                gl_FragColor = Mandelbrot(scaledPos);
//                gl_FragColor = vColor;
            } else {
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
            }
        }
    </script>

    <script>

    var gl;

    function initGL() {

        var canvas = document.getElementById("fractal-canvas");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        try {
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }


    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }


    var shaderProgram;

    function initShaders() {
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader = getShader(gl, "shader-vs");

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

        gl.useProgram(shaderProgram);

        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        if (shaderProgram.vertexPositionAttribute !== -1) {
            gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
        }

        shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
        if (shaderProgram.vertexColorAttribute !== -1) {
            gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);
        }

        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
        shaderProgram.zoomUniform = gl.getUniformLocation(shaderProgram, "zoom");
        shaderProgram.shiftUniform = gl.getUniformLocation(shaderProgram, "shift");
        shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "texSampler");
    }


    var mvMatrix = mat4.create();
    var pMatrix = mat4.create();


    var triangleVertexPositionBuffer;
    var triangleVertexColorBuffer;

    function initBuffers() {
        triangleVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
        var vertices = [
            0.0,  2.0,  0.0,
            3.0, -1.0,  0.0,
            -3.0, -1.0,  0.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        triangleVertexPositionBuffer.itemSize = 3;
        triangleVertexPositionBuffer.numItems = 3;

        triangleVertexColorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexColorBuffer);
        var colors = [
            1.0, 0.0, 0.0, 1.0,
            0.0, 1.0, 0.0, 1.0,
            0.0, 0.0, 1.0, 1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
        triangleVertexColorBuffer.itemSize = 4;
        triangleVertexColorBuffer.numItems = 3;
    }

    var texture;
    function initTexture() {
        texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        var oneDTextureTexels = new Uint8Array([
            255,0,0,255,
            0,255,0,255,
            0,0,255,255
        ]);
        var width = 3;
        var height = 1;
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, oneDTextureTexels);
        //todo what does it do
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        //////////////////////
        gl.bindTexture(gl.TEXTURE_2D, null);
    }

    var zoom = 1;
    var shift = [-0.2, 0];
    var prevPos = [0, 0];

    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        mat4.perspective(55, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

        mat4.identity(mvMatrix);

        mat4.translate(mvMatrix, [0, 0, -1]);

        gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
        if (shaderProgram.vertexPositionAttribute !== -1) {
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexColorBuffer);
        if (shaderProgram.vertexColorAttribute !== -1) {
            gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, triangleVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
        }

        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
        gl.uniform1f(shaderProgram.zoomUniform, zoom);
        gl.uniform2f(shaderProgram.shiftUniform, shift[0], shift[1]);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.uniform1i(shaderProgram.samplerUniform, 0);

        gl.drawArrays(gl.TRIANGLES, 0, triangleVertexPositionBuffer.numItems);
    }

    function toRel(absPos) {
        var scale = Math.max(window.innerWidth, window.innerHeight);
        return [absPos[0] / scale, absPos[1] / scale];
    }

    function toAbs(relPos) {
        var scale = Math.max(window.innerWidth, window.innerHeight);
        return [relPos[0] * scale, relPos[1] * scale];
    }



    function webGLStart() {
        initGL();
        initShaders();
        initBuffers();
        initTexture();

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);

        window.addEventListener('wheel', function(e) {
            var factor = 0.98;
            var zoom0 = 0;
            var zoom1 = 0;

            if (e.deltaY < 0) {
                zoom0 = zoom;
                zoom1 = zoom * factor;
                zoom = zoom1;
            }

            if (e.deltaY > 0) {
                zoom0 = zoom;
                zoom1 = zoom / factor;
                zoom = zoom1;
            }

            var rel = toRel([e.x - window.innerWidth / 2 , e.y - window.innerHeight / 2]);
            var scale = (zoom1 - zoom0);
            var delta = [rel[0] * scale, rel[1] * scale];
            shift[0] -= delta[0] * 2;
            shift[1] += delta[1] * 2;

            drawScene();
        });

        window.addEventListener('mousedown', function(e) {
            prevPos[0] = e.x;
            prevPos[1] = e.y;
        });

        window.addEventListener('mousemove', function(e) {
            if (e.buttons === 1 || e.buttons === 3) {
                var absPos = [prevPos[0] - e.x, e.y - prevPos[1]];
                var relPos = toRel(absPos);
                shift[0] += relPos[0] * zoom * 2;
                shift[1] += relPos[1] * zoom * 2;
                prevPos = [e.x, e.y];
                drawScene();
            }
        });

        drawScene();
    }



    </script>

</head>
<body onload="webGLStart();">
<canvas id="fractal-canvas"></canvas>
</body>
</html>
